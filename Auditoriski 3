Аудиториска вежба 3 (Композиција, const објекти)
1. Задачи
1.1. Средба
Да се дефинира класа Momche која содржи информации за име, презиме и години. За класата да се дефинираат конструктори, деструктор и метод за печатење на објектот на екран во формат:

Momche: Ime Prezime Godini.

Да се дефинира класа Devojche со истите атрибути и методи со разлика во форматот на печатење:

Devojche: Ime prezime godini.

Креирајте класа Sredba која содржи податоци за едно момче и едно девојче.

Креирајте функција print() која ги печати податоците за момчето и девојчето во следниот формат:

Sredba: Momche: Ime Prezime Godini Devojche: Ime Prezime Godini.

Напишете функција daliSiOdgovaraat() која печати “Si odgovaraat” доколку разликата на нивните години е помала или еднаква на 5 или “Ne si odgovaraat” во спротивно.

#include <iostream>
#include <cstring>
#include <cmath>
using namespace std;

class Momche {
private:
    char ime[50];
    char prezime[50];
    int godini;

public:
    Momche() {}

    Momche(char *i, char *p, int g) {
        ::strcpy(ime, i);
        ::strcpy(prezime, p);
        godini = g;
    }

    Momche(const Momche &other) {
        godini = other.godini;
        ::strcpy(ime, other.ime);
        ::strcpy(prezime, other.prezime);
    }

    ~Momche() {}

    void print() {
        cout << "Momche: " << ime << " " << prezime << " " << godini << endl;
    }

    int getGodini() {
        return godini;
    }
};

class Devojche {
private:
    char ime[50];
    char prezime[50];
    int godini;

public:
    Devojche() {}

    Devojche(char *i, char *p, int g) {
        ::strcpy(ime, i);
        ::strcpy(prezime, p);
        godini = g;
    }

    Devojche(const Devojche &other) {
        godini = other.godini;
        ::strcpy(ime, other.ime);
        ::strcpy(prezime, other.prezime);
    }

    ~Devojche() {}

    int getGodini() {
        return godini;
    }

    void print() {
        cout << "Devojche: " << ime << " " << prezime << " " << godini << endl;
    }
};

class Sredba {
private:
    Momche momche;
    Devojche devojche;

public:
    Sredba(const Momche m, const Devojche d) : momche(m), devojche(d) {}

    ~Sredba() {}

    void print() {
        momche.print();
        devojche.print();
    }

    void daliSiOdgovaraat() {
        if (abs(momche.getGodini() - devojche.getGodini()) <5) {
            cout << "Si odgovaraat" << endl;
        } else {
            cout << "Ne si odgovaraat" << endl;
        }
    }
};

int main() {
    int godini;
    char ime[50], prezime[50];

    cout << "Informacii za momche: " << endl;
    cin >> ime >> prezime >> godini;
    Momche m(ime, prezime, godini);

    cout << "Informacii za devojche: " << endl;
    cin >> ime >> prezime >> godini;
    Devojche d(ime, prezime, godini);

    cout << "Dali si odgovaraat: ";
    Sredba s(m, d);
    s.print();
    s.daliSiOdgovaraat();

    return 0;
}


1.2. Екипа
Да се дефинира класа Ekipa што содржи информации за име на екипата, година на формирање и градот од каде потекнува.

Да се дефинира класа Natprevar што содржи информации за домаќин, гостин (објекти од класата Ekipa), голови кои ги постигнал домаќинот и голови кои ги постигнал гостинот.

Да се дефинира посебна функција revans што како аргументи прима два константни (const) објекта од класата Natprevar и проверува дали едниот натпревар е реванш на другиот. 
Еден натпревар е реваш на друг ако гостинот и домаќинот од првиот натпревар се истите екипи со домаќинот и гостинот од вториот натпревар, соодветно.

Да се дефинира функцијата duel која што како аргументи прима два константни (const) објекта од класата Natprevar.
Ако едниот натпревар е реванш на другиот функцијата треба да ја врати екипата која е подобра во меѓусебниот дуел. 
Во спротивно, треба да испечати порака дека натпреварите не се совпаѓаат. Во случајот кога е нерешено функцијата враќа 0.



#include<iostream>
#include<cstring>
using namespace std;

class Ekipa {
private:
    int godina;
    char ime[20];
    char grad[20];
public:
    Ekipa(int _godina = 0, char * _ime = "", char * _grad = "") {
        godina = _godina;
        strcpy(ime, _ime);
        strcpy(grad, _grad);
    }
    const char *getIme() {
        return ime;
    }
    ~Ekipa() {}
};

class Natprevar {
private:
    Ekipa domakin, gostin;
    int goloviDomakin, goloviGostin;
public:
    Natprevar(const Ekipa &d, const Ekipa &g, int gDom, int gGost) {
        domakin = d;
        gostin = g;
        goloviDomakin = gDom;
        goloviGostin = gGost;
    }
    Ekipa getDomakin() const {
        return domakin;
    }
    Ekipa getGostin() const {
        return gostin;
    }
    int getGoloviDomakin() const {
        return goloviDomakin;
    }
    int getGoloviGostin() const {
        return goloviGostin;
    }
    ~Natprevar() {}
};

bool revans(const Natprevar n1, const Natprevar n2) {
    if (!(strcmp(n1.getDomakin().getIme(), n2.getGostin().getIme()) == 0 && strcmp(n1.getGostin().getIme(), n2.getDomakin().getIme()) == 0)) {
        return false;
    }
    return true;
}

Ekipa duel(const Natprevar n1, const Natprevar n2) {
    if (revans(n1, n2)) {
        int eGolovi1 = n1.getGoloviDomakin() + n2.getGoloviGostin();
        int eGolovi2 = n2.getGoloviDomakin() + n1.getGoloviGostin();
        if (eGolovi1 > eGolovi2) return n1.getDomakin();
        else if (eGolovi1 < eGolovi2) return n1.getGostin();
        else if (n1.getGoloviGostin() > n2.getGoloviGostin()) return n1.getGostin();
        else if (n1.getGoloviGostin() < n2.getGoloviGostin()) return n1.getDomakin();
        else return 0;
    }
    else {
        cout << "Ne se sovpagjaat." << endl;
        return 0;
    }
}

int main() {

    Ekipa e1(1880, "Real Madrid", "Madrid");
    Ekipa e2(1880, "FC Barcelona", "Barcelona");

    const Natprevar n1(e1, e2, 1, 2);
    const Natprevar n2(e2, e1, 1, 0);

    cout << duel(n1, n2).getIme();

    return 0;
}




#include<iostream>
#include<cstring>
using namespace std;

class Ekipa {
private:
    int godina;
    char ime[20];
    char grad[20];
public:
    Ekipa(int _godina = 0, char* _ime = "", char* _grad = "") {
        godina = _godina;
        strcpy(ime, _ime);
        strcpy(grad, _grad);
    }
    const char* getIme() {
        return ime;
    }
    ~Ekipa() {}
};

class Natprevar {
private:
    Ekipa domakin, gostin;
    int goloviDomakin, goloviGostin;
public:
    Natprevar(const Ekipa& d, const Ekipa& g, int gDom, int gGost) {
        domakin = d;
        gostin = g;
        goloviDomakin = gDom;
        goloviGostin = gGost;
    }
    Ekipa getDomakin() const {
        return domakin;
    }
    Ekipa getGostin() const {
        return gostin;
    }
    int getGoloviDomakin() const {
        return goloviDomakin;
    }
    int getGoloviGostin() const {
        return goloviGostin;
    }
    ~Natprevar() {}
};

bool revans(const Natprevar n1, const Natprevar n2) {
    if (!(strcmp(n1.getDomakin().getIme(), n2.getGostin().getIme()) == 0 && strcmp(n1.getGostin().getIme(), n2.getDomakin().getIme()) == 0)) {
        return false;
    }
    return true;
}

Ekipa duel(const Natprevar n1, const Natprevar n2) {
    if (revans(n1, n2)) {
        int eGolovi1 = n1.getGoloviDomakin() + n2.getGoloviGostin();
        int eGolovi2 = n2.getGoloviDomakin() + n1.getGoloviGostin();
        if (eGolovi1 > eGolovi2) return n1.getDomakin();
        else if (eGolovi1 < eGolovi2) return n1.getGostin();
        else if (n1.getGoloviGostin() > n2.getGoloviGostin()) return n1.getGostin();
        else if (n1.getGoloviGostin() < n2.getGoloviGostin()) return n1.getDomakin();
        else return 0;
    }
    else {
        cout << "Ne se sovpagjaat." << endl;
        return 0;
    }
}

int main() {

    Ekipa e1(1880, "Real Madrid", "Madrid");
    Ekipa e2(1880, "FC Barcelona", "Barcelona");

    const Natprevar n1(e1, e2, 1, 2);
    const Natprevar n2(e2, e1, 1, 0);

    cout << duel(n1, n2).getIme();

    return 0;
}







